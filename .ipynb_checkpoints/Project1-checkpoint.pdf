{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "601581c8-ae32-4e8f-8536-e35528c20725",
   "metadata": {},
   "source": [
    "# Project 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2e4ed760-efa7-4855-be0d-257b9627e583",
   "metadata": {},
   "source": [
    "**The following packages are used in this project**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "e09c5697-730f-4686-b1c9-0a9884db5aea",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scipy.sparse import csr_matrix\n",
    "import scipy.sparse.linalg as la\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import scipy\n",
    "import time"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "50b9075e-e25d-4a4f-9583-c956384bd9a3",
   "metadata": {},
   "source": [
    "1. **Write a function that loads this file and returns the matrix X and vector y. How many malicious data points are there? What can you say about the sparsity of the data?  Do you think it makes sense to use one-hot-coding for some of the columns?**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f0ce8b77-729e-4dbb-9207-914f717897e7",
   "metadata": {},
   "source": [
    "we use the following code to loads the data file, returns the matrix X and vector y, and count the number of malicious data points:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "47e864a9-9675-4156-b7cc-ef38e061133e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "there are 14700 malicious data points in the total 29332 data points\n"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "class DataLoader:\n",
    "    def __init__(self, file_path= r\".\\data\\data.csv\"):\n",
    "        self.X = None\n",
    "        self.y = None\n",
    "        self.num = 0\n",
    "\n",
    "        self._read(file_path)\n",
    "\n",
    "    def _read(self, file_path):\n",
    "        ori_data = np.loadtxt(file_path, skiprows=1, delimiter=',', dtype=int)\n",
    "        self.X = ori_data[:,:-1]\n",
    "        self.y = ori_data[:,-1]\n",
    "        self.y[self.y == 0] = -1\n",
    "        self.num = self.X.shape[0]\n",
    "\n",
    "    def split(self, ratio = 0.7):\n",
    "        # the number of training data\n",
    "        train_num = int(self.num * ratio)\n",
    "\n",
    "        # shuffling the original data\n",
    "        rand_idx = np.arange(self.num)\n",
    "        np.random.shuffle(rand_idx)\n",
    "        X = self.X[rand_idx]\n",
    "        y = self.y[rand_idx]\n",
    "\n",
    "        # split the data set\n",
    "        X_train, X_test = X[:train_num], X[train_num:]\n",
    "        y_train, y_test = y[:train_num], y[train_num:]\n",
    "\n",
    "        return X_train, X_test, y_train, y_test\n",
    "\n",
    "mydata = DataLoader(r\".\\data\\data.csv\")\n",
    "print(f'there are {(mydata.y == 1).sum()} \\\n",
    "malicious data points in the total {mydata.num} data points')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ae2b207-2fc5-436a-838f-0e52bec26a08",
   "metadata": {},
   "source": [
    "From summing the ones in the data, we get that there are 14700 malicious data points in the total 29332 data points.\n",
    "\n",
    "The dataset is highly sparse, as most feature values are zero.\n",
    "\n",
    "For onw-hot encoding, it is reasonable to apply it when the features represent categorical data without intrinsic ordering. However, for binary features in our project, one-hot encoding may be redundant unless further categorization is needed."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "006f1ba3-1e1d-44fc-8168-5c48b7c4d83b",
   "metadata": {},
   "source": [
    "2. **Write a function that splits the data into a training and test set according to some fraction 0 < r < 1. Make sure to use randomization; that is, it should not be the case that the training set consists of the first data points and the test set of the remaining data points. Your function should return matrices X train and X test and vectors y train and y test.**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "445c9bf1-27db-4eaa-8cfb-187bb539247f",
   "metadata": {},
   "source": [
    "We used the `split` method from the `DataLoader` class shown in **Question 1** to divide the dataset according to the given ratio, where shuffling is implemented before spliting to avoid the case that the training set consists of the first data points and the test set of the remaining data points."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "56327077-481d-4818-b82f-2e138e7244d8",
   "metadata": {},
   "outputs": [],
   "source": [
    "np.random.seed(1234)\n",
    "X_train, X_test, y_train, y_test = mydata.split(ratio = 0.5)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fb1db227-e366-4960-b340-22bf26c38b62",
   "metadata": {},
   "source": [
    "3. **Write a function that, given the matrix X, the vector y, and a weight vector w defining a hyperplane, returns the number of correctly classified points. Verify that the output makes sense for random weight vectors.**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "012600c7-85f3-43b5-bbbc-1efdaa59ce29",
   "metadata": {},
   "source": [
    "We used a randomly generated weight vector `w_init` to define a hyperplane. The followng function is used to compute predictions and the number of correctly classified points for the given input matrix `X`, output `y`and weight vector `w`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "d07764b8-0b5d-4520-93db-009b9ead714d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "11754 data points in total 29332 samples are correct using random generated weights\n"
     ]
    }
   ],
   "source": [
    "def evaluator(X: np.ndarray, y: np.ndarray, w: np.ndarray):\n",
    "    y_pred = X.dot(w)\n",
    "    y_pred[y_pred < 0] = -1\n",
    "    y_pred[y_pred >= 0] = 1\n",
    "    return (y_pred == y).sum()\n",
    "    \n",
    "np.random.seed(1234)\n",
    "w_init = np.random.uniform(low = -1, high = 1, size=(mydata.X.shape[1]))\n",
    "pred_corr_num = evaluator(mydata.X, mydata.y, w_init)\n",
    "print(f'{pred_corr_num} data points in total {mydata.num} samples are correct using random generated weights')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "137fc90f-0f2c-4db9-9b5b-9db817bc11e6",
   "metadata": {},
   "source": [
    "4. **Consider the cost function for logistic regression as defined in the lectures. Write down a symbolic formula for the gradient of this function.**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8dbe7154-0e96-4b3b-bf69-219cb6c50911",
   "metadata": {},
   "source": [
    "The cost function $J(w)$ for logistic regression with regularization is defined as:\n",
    "\n",
    "$$\n",
    "J(w) = \\sum_{i=1}^{n} L(y_i x_i^T w) + \\frac{\\lambda}{2} \\|w\\|^2\n",
    "$$\n",
    "\n",
    "where:\n",
    "\n",
    "$$\n",
    "L(s) = \\log\\left(1 + e^{-s}\\right)\n",
    "$$\n",
    "\n",
    "\n",
    "The gradient of the loss term for a single data point $x_i$ with respect to $w$ is:\n",
    "\n",
    "$$\n",
    "\\nabla_w L(y_i x_i^T w) = -\\frac{y_i x_i}{1 + e^{y_i x_i^T w}}\n",
    "$$\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12f85a4c-6e47-40f5-bd45-93047c63f85c",
   "metadata": {},
   "source": [
    "Therefore, the gradient of the total loss term is:\n",
    "\n",
    "$$\n",
    "\\sum_{i=1}^{n} \\nabla_w L(y_i x_i^T w) = - \\sum_{i=1}^{n} \\frac{y_i x_i}{1 + e^{y_i x_i^T w}}\n",
    "$$\n",
    "\n",
    "The gradient of the regularization term $\\frac{\\lambda}{2} \\| w \\|^2$ with respect to $w$ is:\n",
    "\n",
    "$$\n",
    "\\nabla_w \\left( \\frac{\\lambda}{2} \\|w\\|^2 \\right) = \\lambda w\n",
    "$$\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c610d840-5bd3-4498-b93a-615a129ca620",
   "metadata": {},
   "source": [
    "Thus, the gradient of  $J(w)$ with respect to $w$ is:\n",
    "\n",
    "$$\n",
    "\\nabla_w J(w) = -\\sum_{i=1}^{n} \\frac{y_i x_i}{1 + e^{y_i x_i^T w}} + \\lambda w\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd2ce8a1-2709-4590-94b4-29fc41eebfc5",
   "metadata": {},
   "source": [
    "5.\n",
    "    - **Write a straightforward implementation for logistic regression using gradient descent with a fixed step size $\\alpha$. Your function should take as arguments the data matrix $X$ and data vector $y$, the step size $\\alpha$, the regularization constant $\\lambda$, and an integer $K$ indicating the number of gradient descent steps. The function should return a weight vector $w$.**\n",
    "    - **Experiment with the hyperparameters, using dense and sparse linear algebra, on random splits of training and test data sets. (If you know about writing allocation-free code, you can also experiment with this.)**\n",
    "    - **Given for instance a 50/50 split between test and training data, what is the best classification performance you can obtain on the test set?**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f0e3c5ad-c541-4e3a-b09b-82d23654c08c",
   "metadata": {},
   "source": [
    "In this logistic regression implementation, the constants $\\alpha = 0.01$ (step size), $\\lambda = 0.01$ (regularization constant), and $K = 100$ (gradient descent steps) are chosen initially to test our code."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "497670e0-3956-451f-b3f0-392071b1e2ac",
   "metadata": {},
   "source": [
    "We implement our code in 3 different ways:\n",
    "1. The `logistic_regression_entrywise` method calculates the gradient individually for each data point in every iteration.\n",
    "\n",
    "2. The `logistic_regression_vectorize` method utilizes vectorizing and broadcasting to avoid explicitly calculating the gradient for each data point individually, show as below:\n",
    "   - `s = y * (X @ w)`\n",
    "   - `z = y / (1 + np.exp(s))`\n",
    "   - `w_grad = - (X.T @ z) + lambda_ * w`  "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "863d273b-5ce8-4cbe-9558-f529c2c20b31",
   "metadata": {},
   "source": [
    "3. The `logistic_regression_sparse` method is further optimized by converting training data to a CSR type sparse matrix and using sparse linear algebra, due to the sparsity in our training data."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f1e7d026-315e-4428-9f18-34ee50a042a7",
   "metadata": {},
   "source": [
    "The code implement above is shown as below:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "102884b6-5ccd-4bf4-abb7-070ee5fed088",
   "metadata": {},
   "outputs": [],
   "source": [
    "class LogisticClassifier:\n",
    "    def __init__(self, X_train, y_train, w_init):\n",
    "        self.X_train = X_train\n",
    "        self.y_train = y_train\n",
    "        self.w_init = w_init\n",
    "        self.w = None\n",
    "\n",
    "    def logistic_regression(self, K, alpha, lambda_reg, flag = 0):\n",
    "        if flag == 0:\n",
    "            self.logistic_regression_entrywise(K, alpha, lambda_reg)\n",
    "        if flag == 1:\n",
    "            self.logistic_regression_vectorize(K, alpha, lambda_reg)\n",
    "        if flag == 2:\n",
    "            self.logistic_regression_sparse(K, alpha, lambda_reg)\n",
    "\n",
    "    def logistic_regression_entrywise(self, K, alpha, lambda_reg):\n",
    "        self.w = self.w_init\n",
    "        for k in range(K):\n",
    "            w_grad = lambda_reg * self.w\n",
    "            for i in range(self.X_train.shape[0]):\n",
    "                # if k == 5:\n",
    "                #     print(i)\n",
    "                w_grad -=(self.y_train[i] * self.X_train[i])\\\n",
    "                /(1 + np.exp(self.y_train[i] * self.X_train[i].dot(self.w)))\n",
    "            self.w -= w_grad * alpha\n",
    "        return self.w\n",
    "\n",
    "    def logistic_regression_vectorize(self, K, alpha, lambda_reg):\n",
    "        self.w = self.w_init\n",
    "        for _ in range(K):\n",
    "            s = self.y_train[:,None] * self.X_train @ self.w\n",
    "            z = self.y_train / (1 + np.exp(s))\n",
    "            w_grad = - self.X_train.T @ z + lambda_reg * self.w\n",
    "            self.w -= w_grad * alpha\n",
    "        return self.w\n",
    "\n",
    "    def logistic_regression_sparse(self, K, alpha, lambda_reg):\n",
    "        self.w = self.w_init\n",
    "        self.X_train = csr_matrix(self.X_train)\n",
    "        for _ in range(K):\n",
    "            s_product = self.X_train @ self.w\n",
    "            s = self.y_train * s_product\n",
    "            z = self.y_train / (1 + np.exp(s))\n",
    "            w_grad = - self.X_train.T @ z + lambda_reg * self.w\n",
    "            self.w -= w_grad * alpha\n",
    "        return self.w\n",
    "\n",
    "    def predict(self, X_test, y_test):\n",
    "        w = self.w\n",
    "        y_true =  evaluator(X_test, y_test, w)\n",
    "        acc = y_true / y_test.shape[0]\n",
    "        return acc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "8e4ec830-69c2-4fa0-8d29-d565bc4fbf73",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Entry-Wise Implement:\n",
      " Accuracy on the test set: 94.81%, the time cost is 14.146091222763062s\n",
      "\n",
      "Dense Implement:\n",
      "Accuracy on the test set: 94.74%, the time cost is 2.2567808628082275s\n",
      "\n",
      "Sparse Implement:\n",
      "Accuracy on the test set: 95.30%, the time cost is 0.31095409393310547s\n",
      "\n"
     ]
    }
   ],
   "source": [
    "log_reg = LogisticClassifier(X_train, y_train, w_init)\n",
    "\n",
    "start = time.time()\n",
    "log_reg.logistic_regression(K=100, alpha=0.01, lambda_reg=0.01, flag= 0)\n",
    "accuracy = log_reg.predict(X_test, y_test)\n",
    "end = time.time()\n",
    "print(f'Entry-Wise Implement:\\n Accuracy on the test set: {accuracy * 100:.2f}%, the time cost is {end-start}s\\n')\n",
    "\n",
    "start = time.time()\n",
    "log_reg.logistic_regression(K=100, alpha=0.01, lambda_reg=0.01, flag=1)\n",
    "accuracy = log_reg.predict(X_test, y_test)\n",
    "end = time.time()\n",
    "print(f'Dense Implement:\\nAccuracy on the test set: {accuracy * 100:.2f}%, the time cost is {end-start}s\\n')\n",
    "\n",
    "start = time.time()\n",
    "log_reg.logistic_regression(K=100, alpha=0.01, lambda_reg=0.01, flag=2)\n",
    "accuracy = log_reg.predict(X_test, y_test)\n",
    "end = time.time()\n",
    "print(f'Sparse Implement:\\nAccuracy on the test set: {accuracy * 100:.2f}%, the time cost is {end - start}s\\n')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "47b95fa4-5f1a-4f69-9a4b-653fe4bfffa4",
   "metadata": {},
   "source": [
    "From the above experiment, we haveï¼š\n",
    "1. The three implements achieve similar accuracy with different runing times.\n",
    " \n",
    "2. The `logistic_regression_entrywise` method is quite slow for large datasets because of the iterative sample-by-sample gradient computation, taking approximately 12 seconds for 100 iteration.\n",
    "\n",
    "3. The `logistic_regression_vectorize` method reduces computation time to roughly 1.79 second for 100 iteration.\n",
    "\n",
    "4. The `logistic_regression_sparse` method is the fastest with a rapid runtime of 0.2 seconds for 100 iteration, making it ideal for large, sparse datasets by reducing unnecessary calculations."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd95f488-aca3-490b-9401-aa6e5a3ea122",
   "metadata": {},
   "source": [
    "By experimenting on hyperparameters, the best classification performance we can obtain on the test set with a 50/50 split is 95.55% with $\\alpha = 0.01$ and $\\lambda = 0.1$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "f73c9dce-38a9-4e22-a2d7-7c490052cca0",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\11787\\AppData\\Local\\Temp\\ipykernel_6352\\3012149010.py:43: RuntimeWarning: overflow encountered in exp\n",
      "  z = self.y_train / (1 + np.exp(s))\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "best_acc = 0.9558161734624301, best_alpha = 0.03, best_lambda_reg = 0.1\n"
     ]
    }
   ],
   "source": [
    "best_alpha = None\n",
    "best_lambda_reg = None\n",
    "best_acc = 0\n",
    "for alpha in [0.1,0.03,0.01,0.003,0.001]:\n",
    "    for lambda_reg in [0.1,0.01,0.001,0.0001]:\n",
    "        log_reg.logistic_regression(K=1000, alpha=alpha, lambda_reg=lambda_reg, flag=2)\n",
    "        accuracy = log_reg.predict(X_test, y_test)\n",
    "        if accuracy >= best_acc:\n",
    "            best_acc = accuracy\n",
    "            best_alpha = alpha\n",
    "            best_lambda_reg = lambda_reg\n",
    "\n",
    "print(f'best_acc = {best_acc}, best_alpha = {best_alpha}, best_lambda_reg = {best_lambda_reg}')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "89aff6c6-3ff8-40f6-ae0d-c8d28d2fdb7c",
   "metadata": {},
   "source": [
    "6. Download the file data2.csv. This is the same as the previous data file, except that 2000 fake data points have been appended to the data set. Use the singular value transform as explained in the lecture to detect and remove most of these outliers without removing too many other data points. (For the singular value transform you can use a library function, you do not have to implement this yourself.)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "df63674a-00e2-46c5-ad3d-1a234a3b4c6a",
   "metadata": {},
   "source": [
    "We use the following function to whitening our data:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "fd326dc3-197e-42b8-bcca-c9a9917d3193",
   "metadata": {},
   "outputs": [],
   "source": [
    "def data_whitening(X, k):\n",
    "    # Centering\n",
    "    M = X - X.mean(axis=0)\n",
    "\n",
    "    # SVD Decomposition\n",
    "    U, S, _ = la.svds(M, k=k)\n",
    "\n",
    "    # Whitening\n",
    "    Xw = U[:,::-1] @ scipy.sparse.diags(S[::-1])\n",
    "    Xw = Xw / np.std(Xw, axis=0)[None,:]\n",
    "\n",
    "    return Xw"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bc30aee3-fb93-4da1-aafc-d30ac3540be0",
   "metadata": {},
   "source": [
    "Then we compute the norm of whitenning data to detect the outliers in our data, Within the `noise_removal` function, we employed the `scipy.sparse.linalg.svds` method to compute the top k singular values and their corresponding singular vectors:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "880e94dd-d817-43fa-a402-6f8b3fb7d5bb",
   "metadata": {},
   "outputs": [],
   "source": [
    "def noise_removal(X, k, percentile = 0.9, vis_flag = False):\n",
    "    # Whitening\n",
    "    Xw = data_whitening(X, k)\n",
    "\n",
    "    norm_list = np.array([np.linalg.norm(Xw[i, :]) for i in range(Xw.shape[0])])\n",
    "    outlier_mask = norm_list >= np.quantile(norm_list, percentile)\n",
    "\n",
    "    return outlier_mask"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4dc5977e-8135-4f09-9f2b-a22e724a2cff",
   "metadata": {},
   "source": [
    "Let\n",
    "- TP (True positive) = number of fake samples be detected\n",
    "- FN (False Negative) = number of fake samples be identified as true data points\n",
    "- TN (True Negative) = number of true data points be correctly identified\n",
    "- FP (False Positive) = number of true data point be wrongly identified as fake samples.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c691dfc1-210d-4bec-bc8b-d62c8edef8c8",
   "metadata": {},
   "source": [
    "We use Precision, Recall and F1-score to assess the performance of our method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "3fa5ffa4-8ec7-4750-b73b-ca65b19f3e06",
   "metadata": {},
   "outputs": [],
   "source": [
    "def assess_performance(outlier_mask, vis_flag = False):\n",
    "    confusion_matrix, (P, R), F1 = F1_score(outlier_mask)\n",
    "    acc = (confusion_matrix[0] + confusion_matrix[2]) /\\\n",
    "              (confusion_matrix[0] + confusion_matrix[1] + confusion_matrix[2] + confusion_matrix[3])\n",
    "    \n",
    "    if vis_flag:\n",
    "        visualize_confusion(*confusion_matrix)\n",
    "        print(f'Accuracy: {acc:.4f}')\n",
    "        print(f\"Precision: {P:.4f}\")\n",
    "        print(f\"Recall: {R:.4f}\")\n",
    "        print(f\"F1-score: {F1:.4f}\")\n",
    "\n",
    "    return F1, (P, R), acc\n",
    "\n",
    "def F1_score(outlier_mask, outlier_num = 2000):\n",
    "    \"\"\"\n",
    "    The outlier is in the last #outlier_num rows.\n",
    "    \"\"\"\n",
    "\n",
    "    total_num = len(outlier_mask)\n",
    "\n",
    "    TP = (outlier_mask[-outlier_num:].sum())\n",
    "    FP = (outlier_mask[:-outlier_num].sum())\n",
    "\n",
    "    TN = total_num - outlier_num - FP\n",
    "    FN = outlier_num - TP\n",
    "\n",
    "    Precision = TP / (TP + FP)\n",
    "    Recall = TP / (TP + FN)\n",
    "    F1_score = 2 * (Precision * Recall) / (Precision + Recall) if (Precision + Recall) > 0 else 0\n",
    "\n",
    "    return (TP, FP, TN, FN), (Precision, Recall), F1_score\n",
    "\n",
    "\n",
    "def visualize_confusion(TP, FP, TN, FN):\n",
    "    confusion_matrix = np.array([[TN, FP],\n",
    "                                 [FN, TP]])\n",
    "\n",
    "    categories = ['Normal', 'Outlier']\n",
    "\n",
    "    # plot confusion matrix\n",
    "    plt.figure(figsize=(6, 4))\n",
    "    sns.heatmap(confusion_matrix, annot=True, fmt='d', cmap='Blues',\n",
    "                xticklabels=categories, yticklabels=categories)\n",
    "    plt.xlabel('Prediction')\n",
    "    plt.ylabel('Actual')\n",
    "    plt.title('Confusion Matrix')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a24dc75f-f257-4208-9b2b-9d35ff3f0d65",
   "metadata": {},
   "source": [
    "The we have the following result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "3b38cbd3-47c8-4ff3-9155-0943bf79fcc9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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9ztz5sx1r+Pq9r/6+7VcHS9iz7WYTCaeeeYZPvvsM2bPnk2tWrW4//77r9l2x44ddOjQAbjylMz333/Pzp07efnll+0+77Wu85/6GBkZyeXLlwkMDNTYBxEHUICQYs/FxYW2bduSkJCQbxDktVz9RzQpKSnftpMnT+Ln51dofStVqhQAWVlZNuv/Ps4C4P777+fLL78kPT2d+Ph4wsPDiY6OJjY29rrHL1eu3HWvAyjUa/mryMhITp8+zezZs3nmmWeu2y42NhZXV1e++uorevbsSdOmTWnUqJGhc15rMOr1JCUlMXDgQOrVq8eZM2cYMWKEoXOKiHEKEHJbGD16NBaLhaioqGsOOszJyeHLL78EoE2bNgDWQZBX7dy5kwMHDtC2bdtC69fVJwn27t1rs/5qX67FxcWFxo0b89577wGwe/fu67Zt27YtGzZssAaGqz799FM8PDyK7BHHihUrMnLkSLp160afPn2u285kMlGyZElcXFys6y5dusSCBQvytS2sqk5ubi5PPPEEJpOJb775hpiYGGbMmMHy5ctv+tgiUnCaB0JuC+Hh4bz//vsMGDCAhg0b0r9/f+655x5ycnLYs2cPH3zwAWFhYXTr1o2QkBD69evHjBkzKFGiBJ07d+bo0aOMGTOG4OBgXnjhhULr1wMPPICvry99+/bl1VdfpWTJksybN4/jx4/btJs9ezYbNmygS5cuVKpUicuXL1ufdGjXrt11jz9u3Di++uorWrduzdixY/H19WXhwoV8/fXXTJ06FW9v70K7lr+bPHnyDdt06dKF6dOn07t3b/r168eZM2eYNm3aNR+1rVOnDrGxsSxZsoRq1apRqlQpQ+MWxo0bx3fffceaNWsIDAxk+PDhbN68mb59+1K/fn2qVq1q9zFFxH4KEHLbiIqK4r777uOtt95iypQpJCcn4+rqSq1atejduzeDBg2ytn3//fepXr06H3/8Me+99x7e3t506tSJmJiYa455MMrLy4u4uDiio6N56qmnKFu2LP/+97/p3Lkz//73v63t6tWrx5o1axg3bhzJycmULl2asLAwVq1aZR1DcC0hISFs3bqVl156iYEDB3Lp0iVq167N3Llz7ZrRsai0adOGTz75hClTptCtWzcqVqxIVFQU/v7+9O3b16bthAkTSEpKIioqigsXLlC5cmWbeTIKYu3atcTExDBm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Bo6/8vf3t2kTEBBgs93Hxwc3Nzdrm4IqtJdpde7cmdGjRzN37tzCOqSIiEiRupkKxOjRoxk2bJjNOqPVh169ell/HRYWRqNGjahcuTJff/01Dz/88HX3s1gsNrdhrnVLxkibgii0QZSff/45vr6+hXU4ERGRYs1sNuPl5WWzGA0Qf1ehQgUqV67MoUOHAAgMDCQ7O5u0tDSbdikpKdaKQmBgIKdOncp3rNTUVJs2f680pKWlkZOTk68ycSOGJpL6a0qxWCwkJyeTmprKrFmz7D2ciIiIwxTXGSXPnDnD8ePHrfMuNWzYEFdXV9auXUvPnj0BSEpKYt++fUydOhWA8PBw0tPT2bFjB/fddx8A27dvJz09naZNm1rbvP766yQlJVmPvWbNGsxmMw0bNrSrj3YHiAcffNDmCy9RogTly5enVatW3H333fYerkik7bz+YzIid4pL2bk3biRymytV0qVIj3+r5jK4ePEiv/76q/XzkSNHSExMxNfXF19fX8aPH88jjzxChQoVOHr0KC+99BJ+fn489NBDwJXXRfTt25fhw4dTrlw5fH19GTFiBHXq1LE+lVG7dm06depEVFQUc+bMAaBfv3507dqVkJAQADp06EBoaCgRERG88cYbnD17lhEjRhAVFWXXExgAJovFYimML6c4ufyno3sgUvQUIMQZ+HgUbYAYsvJnw/u+26PgPzRv2rTpmk849OnTh/fff58ePXqwZ88ezp07R4UKFWjdujUTJ04kODjY2vby5cuMHDmSRYsWcenSJdq2bcusWbNs2pw9e5YhQ4awatUqALp3787MmTMpW7astc2xY8cYMGAAGzZswN3dnd69ezNt2jS7b7/YHSBcXFxISkrKN9LzzJkz+Pv720xo4SgKEOIMFCDEGRR1gIj+wniAePvB4lF1dxS7b2FcL29kZWXh5uZ20x0SERG5VfRabuMKHCDeffdd4MqAk48++ojSpUtbt+Xm5vLtt98WmzEQIiIiUrQKHCDeeust4EoFYvbs2bi4/K+s5ObmRpUqVZg9e3bh91BERKSIFNenMG4HBQ4QR44cAaB169YsX74832xYIiIitxvdwjDO7jEQGzduLIp+iIiI3HIqQBhn9yOwjz76KJMnT863/o033uCxxx4rlE6JiIjcCiVMJsOLs7M7QGzevJkuXbrkW9+pUye+/fbbQumUiIjI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FHv27OHBBx+kcuXKlClTxloePnbs2E1dn8g/uVp5KKrBw7t378ZisVCrVi1Kly5tXTZv3szhw4et7dzc3Khbt26R9EHkVlAFwgm1aNGCjh078tJLL9lUFiwWS76/VK9V5vX09My3ztXV1eazyWS65rqrA8UyMjLo0KEDHTp04LPPPqN8+fIcO3aMjh07amCm3JQaNWpgMpn46aefbB61vOrnn3/Gx8cHPz8/TCZTvt/jOTk5N3X+vLw8XFxcSEhIwMXFxWbbXwO1u7u7noCS25oChJOaPHky9erVo1atWtZ1oaGhbNmyxabd1q1bqVWrVr6/CG/Wzz//zOnTp5k8eTLBwcEA7Nq1q1DPIc6pXLlytG/fnlmzZvHCCy/YjINITk5m4cKFPP3005hMJsqXL09SUpJ1+6FDh8jMzLR+dnNzA7CpwN1I/fr1yc3NJSUlhfvvv78QrkikeNItDCdVp04dnnzySWbMmGFdN3z4cNavX8/EiRP55ZdfmD9/PjNnzrQZ71BYKlWqhJubGzNmzOC3335j1apVeo5eCs3MmTPJysqiY8eOfPvttxw/fpy4uDjat29PxYoVef3114Er43lmzpzJ7t272bVrF88//7xN5czf3x93d3fi4uI4deoU6enpNzx3rVq1ePLJJ3n66adZvnw5R44cYefOnUyZMoXVq1cX2TWL3GoKEE5s4sSJNuXbBg0asHTpUmJjYwkLC2Ps2LG8+uqrRfJkRPny5Zk3bx7/93//R2hoKJMnT2batGmFfh5xTjVr1mTXrl1Ur16dXr16Ub16dfr160fr1q3Ztm0bvr6+ALz55psEBwfTokULevfuzYgRI/Dw8LAep2TJkrz77rvMmTOHoKAgHnzwwQKdf+7cuTz99NMMHz6ckJAQunfvzvbt263VNpE7gV7nLSIiInZTBUJERETspgAhIiIidlOAEBEREbspQIiIiIjdFCBERETEbgoQIiIiYjcFCBEREbGbAoSIiIjYTQFCpBgbP3489erVs36OjIy85gui7FEYxxARUYAQMSAyMhKTyWR962i1atUYMWIEGRkZRXred955h3nz5hWo7dGjRzGZTCQmJho+hojI9ehtnCIGderUiblz55KTk8N3333Hv//9bzIyMnj//fdt2uXk5OR7tblR3t7exeIYIiKqQIgYZDabCQwMJDg4mN69e/Pkk0+ycuVK622HTz75hGrVqmE2m7FYLKSnp9OvXz/8/f3x8vKiTZs2/PDDDzbHnDx5MgEBAZQpU4a+ffty+fJlm+1/v/2Ql5fHlClTqFGjBmazmUqVKlnfNFm1alXgyuulTSYTrVq1uuYxsrKyGDJkCP7+/pQqVYrmzZuzc+dO6/ZNmzZhMplYv349jRo1wsPDg6ZNm3Lw4MFC/DZF5HajACFSSNzd3cnJyQHg119/ZenSpSxbtsx6C6FLly4kJyezevVqEhISaNCgAW3btuXs2bMALF26lHHjxvH666+za9cuKlSowKxZs/7xnKNHj2bKlCmMGTOGn376iUWLFhEQEADAjh07AFi3bh1JSUksX778msd48cUXWbZsGfPnz2f37t3UqFGDjh07Wvt11csvv8ybb77Jrl27KFmyJM8++6zh70pE7gAWEbFbnz59LA8++KD18/bt2y3lypWz9OzZ0zJu3DiLq6urJSUlxbp9/fr1Fi8vL8vly5dtjlO9enXLnDlzLBaLxRIeHm55/vnnbbY3btzYcu+9917zvOfPn7eYzWbLhx9+eM0+HjlyxAJY9uzZc92+X7x40eLq6mpZuHChdXt2drYlKCjIMnXqVIvFYrFs3LjRAljWrVtnbfP1119bAMulS5eu/yWJyB1NFQgRg7766itKly5NqVKlCA8Pp0WLFsyYMQOAypUrU758eWvbhIQELl68SLly5ShdurR1OXLkCIcPHwbgwIEDhIeH25zj75//6sCBA2RlZdG2bVvD13D48GFycnJo1qyZdZ2rqyv33XcfBw4csGlbt25d668rVKgAQEpKiuFzi8jtTYMoRQxq3bo177//Pq6urgQFBdkMlPT09LRpm5eXR4UKFdi0aVO+45QtW9bQ+d3d3Q3t91cWiwUAk8mUb/3f1/31+q5uy8vLu+k+iMjtSRUIEYM8PT2pUaMGlStXvuFTFg0aNCA5OZmSJUtSo0YNm8XPzw+A2rVrEx8fb7Pf3z//Vc2aNXF3d2f9+vXX3O7m5gZAbm7udY9Ro0YN3Nzc2LJli3VdTk4Ou3btonbt2v94TSLi3FSBELkF2rVrR3h4OD169GDKlCmEhIRw8uRJVq9eTY8ePWjUqBFDhw6lT58+NGrUiObNm7Nw4UL2799PtWrVrnnMUqVKMWrUKF588UXc3Nxo1qwZqamp7N+/n759++Lv74+7uztxcXHcddddlCpVKt8jnJ6envTv35+RI0fi6+tLpUqVmDp1KpmZmfTt2/dWfDUicptSgBC5BUwmE6tXr+bll1/m2WefJTU1lcDAQFq0aGF9aqJXr14cPnyYUaNGcfnyZR555BH69+/Pf//73+sed8yYMZQsWZKxY8dy8uRJKlSowPPPPw9AyZIleffdd3n11VcZO3Ys999//zVvoUyePJm8vDwiIiK4cOECjRo14r///S8+Pj5F8l2IyJ3BZLl6E1RERESkgDQGQkREROymACEiIiJ2U4AQERERuylAiIiIiN0UIERERMRuChAiIiJiNwUIERERsZsChIiIiNhNAUJERETspgAhIiIidlOAEBEREbv9P88yLbQuuEEvAAAAAElFTkSuQmCC",
      "text/plain": [
       "<Figure size 600x400 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Accuracy: 0.9796\n",
      "Precision: 0.8405\n",
      "Recall: 0.8405\n",
      "F1-score: 0.8405\n"
     ]
    }
   ],
   "source": [
    "# read data\n",
    "my_data = DataLoader(r\".\\data\\data2.csv\")\n",
    "X = my_data.X.astype('float64')\n",
    "\n",
    "# Outlier rate\n",
    "q = 1 - 2000 / X.shape[0]\n",
    "\n",
    "# data whitening & noise removal\n",
    "F1, _, _ = assess_performance(noise_removal(X, 81, q), vis_flag=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37cd9f15-36d4-4489-b207-aecdeb95d95f",
   "metadata": {},
   "source": [
    "In the plot of confusion matrix, we found that:\n",
    "- The diagonal elements (29,013 normal points and 1,681 outliers) indicate correctly classified instances.\n",
    "    \n",
    "- Off-diagonal elements (319 misclassified as normal and 319 asoutliers) indicate errors\n",
    "\n",
    "- Majority of outliers was removed and only a few truer data point was misclassifieds."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e9365e2a-fd7b-4317-86e2-038f5a6dab63",
   "metadata": {},
   "source": [
    "By adjusting the threshold for classifying a data point as an outlier or not, we obtain different classification results, focusing either on detecting more true positives (TP) or on detecting true positives with greater accuracy. The precision-recall curve is shown belowï¼š\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "2e3853d4-f12c-4e84-8206-4c9a85a7fbb3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Progress: 99% (q = 0.99)\r"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAArQAAAIlCAYAAAAkBGs8AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8fJSN1AAAACXBIWXMAAA9hAAAPYQGoP6dpAABOIUlEQVR4nO3dd3hUZf7+8XuSmTQgoYdAQgDpUhRQuoA0QUGxAItLE7/KssIqoj8QVgFBLMiCS3NdhEUUEURwVxSygjQLiKDSVKQJJGCCkNBCyvn9cXYmiQlpJHNyJu/XdZ0rkzNnZj4zPISbJ5/zHIdhGIYAAAAAm/KzugAAAADgehBoAQAAYGsEWgAAANgagRYAAAC2RqAFAACArRFoAQAAYGsEWgAAANgagRYAAAC2RqAFAACArRFoAfiEJUuWyOFwaMmSJYV6fOfOneVwOIq2qFJs2LBhcjgcOnr0qGff0aNH5XA4NGzYMMvqAuCbCLQAcuUOIZm3gIAARUVFadCgQfruu++sLtFn1apVK8vn7u/vr0qVKqlr165auXKl1eV5TWpqqhYvXqzevXurWrVqCggIUFhYmG655RZNmjRJx44ds7pEABZzWl0AAHu44YYb9Mc//lGSdOHCBX355Zdavny5Vq9erY0bN6pdu3aW1tevXz+1adNGERERhXr80qVLdenSpSKu6vr5+/tr0qRJkqSUlBT99NNPWrNmjTZu3KgZM2Zo/PjxFldYvI4dO6a7775b3377rcLDw9W9e3dFRUXp4sWL+uabb/Tiiy9q5syZ2rt3r+rWrWt1uQAsQqAFkC9169bV5MmTs+ybNGmSpk+frokTJ2rTpk3WFPY/YWFhCgsLK/Tja9asWYTVFB2n05ntc9++fbtuu+02TZ06VWPGjFFISIg1xRWzpKQk9ezZUz/88IOeeuopTZ06VUFBQVmOOXTokMaOHasLFy5YVCWAkoCWAwCFNnr0aEnSzp07PfscDoc6d+6skydPatiwYapWrZr8/Pz02WefeY7ZsmWL+vTpo8qVKyswMFD16tXTpEmTrjlDunXrVvXr10/h4eEKDAxUVFSU7r33Xm3bts1zzLV6aL/55hvdf//9qlmzpgIDAxUeHq62bdvqxRdfzHLctXpoU1NT9be//U3NmzdXcHCwwsLC1KVLF3300UfZjs1cw6effqoOHTqoTJkyqlSpkoYOHaqEhIQ8P9P8aN++vRo2bKjLly9r//792e5fu3atunbtqgoVKigoKEhNmjTRzJkzlZaWluPzffjhh+rZs6cqVaqkoKAg1apVS4MHD9bevXs9x/z44496+umn1aJFC89x9evX1/jx44stTM6cOVM//PCD/vjHP+rll1/OFmYl8z9aH374oRo3biwp7z5d9/jMzP1nn5ycrGeffVZ169aVy+XS5MmT9dBDD8nhcGjr1q05Pt/06dPlcDj01ltvZdn/3XffaeDAgYqIiFBAQICio6M1evToIhsDALJihhZAoV3rJKqEhAS1bdtWFStW1IABA3T16lWFhoZKkhYuXKhRo0apQoUK6tOnj6pUqaKdO3dq+vTp2rRpkzZt2qSAgADPc82bN0+jR49WcHCw+vXrp5o1a+rkyZPatm2bVq1apQ4dOlyzvj179qhdu3by9/fX3XffrejoaJ07d0779u3TG2+8keev6w3D0IABA7R69WrVr19ff/7zn3Xx4kW99957uuuuuzRnzhyNGTMm2+P+/e9/6z//+Y/69OmjP/3pT9qyZYuWLl2qn3/+OUsIvx6GYUgyZ3Aze+aZZzRjxgxFRkbqvvvuU2hoqLZs2aKnnnpKX331Vbbe26efflqvvPKKKlasqHvuuUdVq1bVL7/8ov/+979q2bKlmjRpIklavXq1Fi1apC5duqhz585KT0/Xl19+qZdeekmbN2/Wli1b5HK5iuS9ub355puSpGeffTbPYzOPmcK699579e2336pnz56qWLGi6tSpo06dOmnx4sVatmyZOnbsmO0xb7/9tsqUKaN+/fp59n344Yfq37+//P391bdvX0VFRWn//v2aO3eu1q9fr6+++koVKlS47noBZGIAQC6OHDliSDJ69uyZ7b6JEycakozOnTt79kkyJBnDhw83UlNTsxy/b98+w+l0GjfffLORkJCQ5b4ZM2YYkoyZM2d69n333XeGv7+/Ub16dePIkSNZjk9PTzdOnjzp+X7x4sWGJGPx4sWefWPHjjUkGWvXrs1We3x8fJbvO3XqZPz+R+LSpUsNSUanTp2M5ORkz/5ffvnFqFq1quFyuYzDhw9nq8HpdBrbtm3z7E9NTTU6d+5sSDK++OKLbLVcS3R0tBEYGJht/+bNmw0/Pz+jUqVKxuXLlz37N2zYYEgyevXqZVy8eNGzPz093Rg5cqQhyVi1apVn/0cffWRIMpo2bZrt80hJSTHi4uI83584cSLLZ+A2ZcoUQ5KxbNmyLPuHDh1qSMry5+YeS0OHDs3zvR89etSQZERGRuZ5bGZ5vYb7zzMz95/9TTfdlG1cpqenG1FRUUaFChWyvf+vv/7akGT88Y9/9OyLj483QkNDjcjISOPYsWNZjn/nnXcMScZjjz1WoPcEIG+0HADIl0OHDmny5MmaPHmyxo0bpw4dOmj69OkKCgrSCy+8kOXYgIAAvfzyy/L398+y//XXX1dqaqpee+01VaxYMct9Tz/9tKpUqaLly5d79i1cuFBpaWmaNm2aatWqleV4h8Oh6tWr56v24ODgbPsqVaqU5+Pc7Qsvv/xylhnAyMhIPfHEE0pJSdHbb7+d7XGDBg1S+/btPd/7+/tr6NChkrK2Z+RHamqq53OfOHGi+vfvr27dusnhcGjevHlZfg0/d+5cSebnnLmv1uFw6MUXX5TD4cjy+c6bN0+SNGfOnGyfh9PpVHh4uOf7GjVq5DgL+thjj0mS/vvf/xbofeUlLi5OkvlZe8uUKVOyjUuHw6FBgwbpt99+y9ZmsmzZMknynCwpmScXJiYmasaMGdn6sv/whz+oRYsWevfdd4vpHQClFy0HAPLl559/1pQpUyRJLpdL4eHhGjRokMaPH6+mTZtmObZ27dqqXLlytuf48ssvJUmffPJJjgHI5XLp4MGDnu937NghSerRo0ehar7//vs1e/Zs3XPPPerfv7+6d++uDh065PsEsN27dys4OFi33nprtvvcfZh79uzJdl+LFi2y7XMHs3Pnznn2zZ49O8v3krl+a+bwnpaW5vnc3fz9/bVixQrdd999WfZ/+eWXKlOmjBYtWpTj+wkODs72+QYGBqpTp045Hp+ZYRhavHixlixZor179+r8+fNKT0/33H/q1Kk8n6Oky+nPWZIGDx6sl156ScuWLfO0FqSlpWn58uWqVq2aunXr5jnWPca//PJLHTp0KNtzXblyRfHx8YqPj8/x7wiAwiHQAsiXnj176pNPPsnXsZln9jI7e/asJPNEmvw4d+6cHA5HoZfiatu2rWd5q+XLl3tmXFu2bKlXXnlFXbp0yfXxiYmJioqKyvG+atWqSZLOnz+f7b6cVltw97pmPjFr9uzZ2dZQ7dy5c5ZAGxgYqCtXrkgyl0vbuHGjHnroIQ0bNkx169ZV8+bNPceePXtWqamp2QJwZhcvXvTcPnfunGrUqCE/v7x/WTdmzBjNnTtXUVFR6tu3ryIiIhQYGCjJnNlMTk7O8zkKwv35njx5skifNzfXGrc33nijbr75Zn300Uc6d+6cypcvr5iYGJ0+fVpjx47N8psI9xh3z35fy8WLFwm0QBGi5QBAkbvWyWLuE8MSExNlGMY1N7fy5cvLMAzFxsYWupZOnTrpk08+0W+//aZNmzZp7Nix2rdvn+688079/PPPuT42NDRUp0+fzvE+9373eyqMo0ePZnvvvz8DP7OyZcuqb9++WrFihS5cuKBhw4Zl+bxCQ0NVqVKlXD/bI0eOeI4vX7684uLissy05uTMmTOaN2+emjVrpoMHD2rJkiWaMWOGJk+erJEjRxb6/ecmOjpaNWrU0C+//KKffvop349zh/PU1NRs9+X0n4/McrtS3ODBg5WcnKxVq1ZJymg3GDx4cJbj3OPh+++/z/XPITo6Ot/vCUDeCLQAvKZ169aSMn4tmxf3r4A3bNhw3a8dHByszp0769VXX9Uzzzyjy5cv59n3efPNN+vy5cue1ofMNm/eLEm66aabrru2guratavuuece7dmzJ0tPbOvWrZWQkJDvAHjrrbcqOTnZ816u5fDhwzIMQ926dcu25u21lrMqCiNGjJAkTZs2Lc9jr169KskM6VLOM7u7d+8udC1/+MMf5O/vr2XLlunixYtas2aNbrzxxmx//u4x/sUXXxT6tQAUHIEWgNeMGjVKTqdTo0eP1i+//JLt/nPnzmUJHSNHjvRcKev3v5rPz8zt1q1blZiYmG2/e3Y1p5PFMnOfyDVhwgSlpKR49p88eVKzZs2S0+nUgw8+mOtzFJfJkyfL4XBoypQpnjYG9xJiDz30UI7rncbFxenAgQOe7//85z9Lkv7yl794flXulpqa6vmc3LOJn3/+eZbZ3BMnThTrlcrGjRunBg0aaOnSpXrmmWdybGs4cuSI7rnnHs96vKGhoapfv762bduWpYc1KSlJEyZMKHQt7l7ZLVu2aM6cObp48WK22VlJGj58uMqVK6eJEydq37592e6/dOlSvv9DByD/6KEF4DVNmjTR/Pnz9ac//UkNGjRQ7969dcMNNygxMVGHDx/W5s2bNWzYMC1cuFCS1LRpU82ePVtjxozRjTfeqHvuuUfR0dGKi4vTli1bdOedd2r27NnXfL1XX31VMTEx6tKli+rUqaOgoCB98803+vTTT1W3bt0sa4fmZPDgwVq9erXWrl2rZs2a6a677vKsQ5uQkKBXX31VderUKcqPKN+aN2+ufv36afXq1Vq2bJmGDh2qO+64Q3/961/1/PPPq27durrjjjsUHR2thIQEHTp0SFu3btW0adPUqFEjSVLv3r01btw4zZw5U/Xq1VO/fv1UtWpVnTx5Up9++qnGjRunxx9/XBEREbrvvvv0/vvvq1WrVuratatOnz6t//znP7r99tt1+PDhYnmP5cqV0/r163X33XdrxowZWrx4sXr06KHIyEhdunRJu3fv1vbt2+V0OjVz5kzP48aOHauRI0eqbdu2euCBB5Senq6PP/5YrVq1uq56Bg8erPXr12vy5Mny8/PL8T8z7pU6HnjgATVv3lx33HGHGjZsqCtXrujYsWPavHmz2rVrl+9+dAD55I21wQDYV27r0OZEOazz+Xs7duwwBg4caFSvXt1wuVxG5cqVjRYtWhjjx483Dhw4kO34TZs2GXfddZdRsWJFIyAgwIiMjDTuu+8+Y/v27Z5jclqH9pNPPjGGDBliNGjQwChXrpxRtmxZo3HjxsakSZPytQ6tYZjrsc6cOdNo2rSpERgYaJQrV87o1KlTjmvb5lRD5vcgyXjuuedy/Wwyu9Y6tG7ffvut4XA4jDp16hgpKSme/TExMUafPn2MKlWqGC6Xy6hWrZrRtm1b4/nnnzeOHz+e7Xnef/99o0uXLkZYWJgRGBho1KpVyxg8eLCxd+9ezzFJSUnGk08+adSqVcsIDAw06tWrZzz//PPG1atXc/wzv951aDO7evWq8eabbxp33HGHER4ebrhcLqNcuXJGixYtjAkTJuT4nv7+978bdevWNVwul1GzZk3j2WefvWat1/qz/72LFy8aZcuWNSQZXbp0yfXYgwcPGiNGjDCio6ONgIAAo0KFCkbTpk2NMWPGGDt27CjQ+weQN4dhZDqjAAAAALAZemgBAABgawRaAAAA2BqBFgAAALZGoAUAAICtEWgBAABgawRaAAAA2FqpvLBCenq6Tp06pXLlyuV67W4AAABYwzAMJSUlqXr16vLzy30OtlQG2lOnTikqKsrqMgAAAJCHX375RZGRkbkeUyoDbbly5SSZH1BoaKjF1ZRcKSkp2rBhg3r06CGXy2V1ObAI4wCMAUiMA3h/DCQmJioqKsqT23JTKgOtu80gNDSUQJuLlJQUhYSEKDQ0lB9epRjjAIwBSIwDWDcG8tMeyklhAAAAsDUCLQAAAGyNQAsAAABbI9ACAADA1gi0AAAAsDUCLQAAAGyNQAsAAABbI9ACAADA1gi0AAAAsDUCLQAAAGyNQAsAAABbI9ACAADA1gi0AAAAsDUCLQAAAGyNQAsAAABbI9ACAADA1pxWFwAAyJ/Ll6WEBHOLj5cuXpQqV5bCw82tbFmrKwQAaxBoAcDLDMMMo/HxGeE0c1C91r5Ll3J/3pAQM9hWrZoRcjNvmfeXLy85HF55uwBQ7Ai0AHAdDEM6fz7/odT99erVwr2e0ylVqmTOzIaEmM93+rQZdi9dko4cMbe8BARkBNy8AnBoaOFqBQBvIdACwP+kpUm//Zb/UOre0tIK93qBgWYwdQfUnL7+fl+5cjnPrF64YAbb06elM2cybv9+O3PGDOBXr0onTphbXvz8nAoN7amoKKeqVcs9BFepIrlchfs8AKCwCLQAfFJKStbQmZ+A+ttv5oxrYZQpc+0Qeq2AGhJSdL/2L1vW3G64Ie9jr1zJHnqvFYITEqT0dIfOnQvSuXPS99/n/fwVK+be7pB5Cwq67rcOAARaACXflSsFmzWNj5cSEwv/emFh+Zstde+rVMlewSwoSKpZ09zykpoqnTqVovff36b69TsqIcF5zQD866/mbPXZs+Z24EDezx8amr+eX/dJb/T9AsgJgRaA17hPhirIiVDx8XmfDHUtDoc5W1iQWdOKFfmVeWZOpxQRIdWpk6gePYxcP5v0dPPP7Fqzvb/ff/Wq+R+PxETp0KG8awkOzv9JbxUqEH6B0oRAC6BA0tOl5GRz1vTyZTNsnj2b/9nT5OTCva6/f96zpb+/r3x583HwDj8/s4e2ShXpxhtzP9Z9Ml1u7Q6Z91+8aI63o0fNLS8uV94nvbnvq1yZcQLYHYEWsCHDMHtE3aHyypWst3Pal5/bOd/v1LlzPWUYTl25UvhAmllAQP5PgnLvCwtjxs2XOBzmfzjKl5caNMj7+IsX89fze+aMdO6c+ffj5Elzy4ufn1StmhnCmzaVmjQxvzZubPY5Ayj5CLTAdUhLu56gWPjHXblizpR6h0NSzg2ifn7mr4Ez95LmJ6CWKUM4RcGUKSPVqWNueUlOLuhJb9KpU+YWE5PxPA6HeZKdO+C6v9arZ7ZiACg5+CsJn3T1qnlCivvXlMUVNlNTrX6npqAgcwsOzv/t/B7rdKZq586t6t69g8qVc2U5hl5TlESBgVJUlLnlJTXVbIk5elTau9dcxcH99ddfzd7eQ4ekNWsyHhMQIDVqZAbczGG3Zk3+owZYhUALn5CSIu3cKX32mbRpk7R9uxk4vcnlKtogmd/nCAws3n9EU1IMxccnqn59Aix8j9NpthtUqya1aZP1vjNnsofcvXvN/yh/+625ZVauXPbZ3CZNzN9MACheBFrYUkqKtGuXGV4/+0zati37mfDly5u/3i6uIJn5dlAQJ5UAvqZqVen2283NLT1dOnYse9A9eFBKSpK++MLcMqtWLWvAbdLE7NctU8a77wfwZQRa2EJqqhlg3TOw27aZsySZVaokdeokdekide5sntDh52dFtQB8lZ+fVLu2ufXpk7H/6lXpp5+yz+YePizFxZnbf/+bcbzDYT7H72dz+U0IUDgEWpRIqanSN9+YAfazz6StW81Le2ZWsaIZYDt3NkPsjTcSYAFYIyDA/Bn0++XKLlyQ9u/PHnRPnzbD7uHD0tq1Gce7XFLDhllnc5s2Nftz+fkGXBuBFiVCaqq0Z09GC8HWreav7zIrXz7rDGzTpvyAB1CylS0r3XqruWX2669msM0ccvfuNX/uff999ksMly2b/SS0pk3NNX8BEGhhkbQ0M8C6Wwi2bs1+qdLy5aXbbssaYOlTBeALqlQxf7Z16ZKxzzCk48ezz+YeOGDO9H75pbllVrVq9tncG280AzBQmhBo4RVpaeYZwe4Wgi1bzKsEZRYWZgZYdwtBs2YEWAClh8MhRUeb2113ZexPScnan+sOu4cPmysxfPqpuWVWu3b22dz69c3WCMAXEWhRLNLTpe++y2gh2LLFvHpPZqGhGQG2c2fpppsIsADwey6XeZJr48bSgAEZ+y9eNPtzf7/iQlycdOSIuf373xnHO51mf+7vV1yoVYv2LdgfgRZFIj3d/EHqbiHYskX67besx5QrJ3XsmNFCcNNNXG0HAAqrTBnpllvMLbP4+Jz7cxMTM26/+27W5/n9ZX+bNJHCw737foDrQZxAoaSnmz8U3S0EmzdLZ89mPaZsWTPAulsIbr6ZAAsAxa1y5YzffLkZhvTLL9lnc91XVNyxw9wyq1Ila8Bt2NChlBSmclEyES+QL+np5q+23C0Emzeb10DPrEyZjADbubPUsiUBFgBKAofDXPqrZk2pd++M/ampZn/u72d0Dx0yV2LYtMncTE6FhNyhe+/118CBUvfu9OSi5CBuIEeGIe3bJ61bV1tLl/pryxbz11iZhYRIHTpktBC0bMmC4ABgJ06n1KiRuT3wQMb+S5fM2dvMs7m7dxv69VeXli2Tli0zV6K55x7zcd26EW5hLQItJJkB9sCBjBaCzz6Tfv3VJamZ55iQEKl9+4wWglatCLAA4ItCQsxJipYtM/YlJ6dq1qwvdfJkO61e7a/YWGnJEnMrX17q188Mt127Em7hfQTaUsowpB9+yGgh+Owzc/mXzIKDDdWv/6vuvbeSunb11y238EMKAEorPz+pceOzGjcuXXPm+Gv7dmnlSmnVKnNlhcWLza1CBTPc9u8v3X47Ex/wDgJtKWEY0o8/Zp2BjYvLekxQkNSuXeZVCFL16adfqHfv3nK5WE8LAGDy9zeXXbztNmn2bGnbtoxwe/q09Oab5laxYka47dKFcIviQ6D1UYZhNvpnDrCxsVmPCQw0A6y7heDWW819bikp3qsXAGBP/v7mZck7dZLmzDGv/Pjee9L775u/+Vu0yNwqVpTuvTcj3HLSMIoSw8lHGIb0889ZWwhOncp6TGCg1LZt1gAbFGRBsQAAn+Tvn7HSzd//bq5J7g63v/4q/fOf5la5csbMbefOhFtcP4aQTRmGedlDd3jdtEk6eTLrMQEBUps2GS0EbdoQYAEA3uHvb/7706VL9nAbHy+98Ya5Va4s3XefeUJZp06EWxQOw8YmDEM6ejTrDOwvv2Q9xuUyQ6t7BrZNGyk42Pu1AgCQmdNpniB2++3S3Lnmv2ErV2aE29dfN7cqVbKGWy6Hjvwi0JZgR49mzL5+9pl0/HjW+10uqXXrrAE2JMT7dQIAkF9Op7lubbduGeH2vfekDz4w2xIWLjS3qlXNcNu/v3nRHsItckOgLUGOHcvaQnDsWNb7nc6MANu5s3lCFwEWAGBXLpd5xbHu3aX5881/+957T1q92jyhbMECcwsPzwi3HToQbpEdgdZCv/yStYXgyJGs9zud0i23ZPTAtmtnXl4WAABf43JJPXqY24IF0saNGTO3p0+bgXf+fKlatYxw27494RYmAq0XnTiRtYXg8OGs9/v7mwHW3ULQrp1UtqwFhQIAYCGXS+rZ09wWLJA+/dTsuf3gA3MN9XnzzC0iImu49fOzunJYhUDrBa+/Lr3yirmsVmb+/ublY90tBO3bS+XKWVEhAAAlU0CA1KuXuS1cKP33vxnhNjbW7MOdO1eqXl26/37zhLJ27Qi3pQ2B1gtSU80w6+dnXhfb3ULQvr0UGmp1dQAA2ENAgNS7t7m5w+1770lr15prr7/2mrnVqJERbtu2JdyWBgRaL7jnHql2bbORnQALAMD1CwyU7rzT3JKTpZiYjHB78qR51bI5c8xw+8ADZltC69aEW1/FH6sX1Khh/m+SMAsAQNELDJTuuktautRcHeHDD6U//tFs4zt5Upo922xDiI6Wxo6VvvzSXN8dvoNACwAAfEZgoNSnj/TWW2a4XbNGevBB8yTrEyekv/3NbEOoVUt68knpq68It76AQAsAAHxSUJB0993SsmVmuP3gA2nQIDPcHj8uzZplXpSodm1p3Dhpxw7CrV0RaAEAgM8LDjbPaXn7bTPcrl4tDRxoru9+7Jj06qtmj23t2tLTT2e/OidKNgItAAAoVYKDpX79pOXLzXD7/vvSgAHm1TePHTOX2rzxRumf/2TG1i4ItAAAoNQKCZHuvVd6913p11+lVavME8guXJD+7//MVRROnbK6SuSFQAsAACAz3N53n7RlizRzpnmC2ccfm7O1b7/NbG1JViIC7fz581W7dm0FBQWpZcuW2rp1a67Hv/3222revLlCQkIUERGh4cOHKyEhwUvVAgAAX+bvb66A8M035hU9z50zlwG77z6zRQElj+WBdsWKFXr88cc1ceJE7d69Wx07dlSvXr10/Brd2Nu2bdOQIUM0YsQI7du3TytXrtTOnTv18MMPe7lyAADgyxo3lj7/XHr+ecnpNFdJuPFG84QylCyWB9pZs2ZpxIgRevjhh9WoUSPNnj1bUVFRWrBgQY7Hf/nll6pVq5bGjBmj2rVrq0OHDnr00Uf19ddfe7lyAADg61wuadIkaedOqWlTKT7enKl98EHp7Fmrq4ObpZe+vXr1qnbt2qXx48dn2d+jRw99/vnnOT6mXbt2mjhxotatW6devXrpzJkzWrVqle68885rvk5ycrKSk5M93ycmJkqSUlJSlJKSUgTvxDe5Pxs+o9KNcQDGACTGwY03mrO106b56ZVX/PTOOw5t2mRo4cI09epVOpprvT0GCvI6DsOwrsX51KlTqlGjhrZv36527dp59r/wwgv617/+pR9++CHHx61atUrDhw/XlStXlJqaqr59+2rVqlVyuVw5Hj958mRNmTIl2/533nlHISEhRfNmAABAqfDjjxU0Z87NOnmynCSpW7djeuihvQoJSbW4Mt9y6dIlDRo0SOfPn1doaGiux5aIQPv555+rbdu2nv3Tp0/XW2+9pYMHD2Z7zP79+9WtWzc98cQT6tmzp2JjY/XUU0/plltu0aJFi3J8nZxmaKOiohQfH5/nB1SapaSkKCYmRt27d7/mfxbg+xgHYAxAYhz83uXL0rPP+um11/xkGA7VrGnojTfS1KWL787WensMJCYmqnLlyvkKtJa2HFSuXFn+/v6Ki4vLsv/MmTMKDw/P8TEzZsxQ+/bt9dRTT0mSmjVrpjJlyqhjx46aNm2aIiIisj0mMDBQgYGB2fa7XC7+UuYDnxMkxgEYAzAxDkwulzR7trmG7bBh0pEjDvXs6dRjj0kvvmhegcxXeWsMFOQ1LD0pLCAgQC1btlRMTEyW/TExMVlaEDK7dOmS/Pyylu3v7y9JsnCyGQAAlEK33SZ99500cqT5/dy50k03mf228B7LVzkYO3as/vnPf+rNN9/UgQMH9MQTT+j48eMa+b+RMWHCBA0ZMsRzfJ8+fbR69WotWLBAhw8f1vbt2zVmzBjdeuutql69ulVvAwAAlFJly0oLFkjr10uRkdKhQ1KHDtLTT0tXrlhdXelgacuBJA0YMEAJCQmaOnWqYmNj1aRJE61bt07R0dGSpNjY2Cxr0g4bNkxJSUmaO3eunnzySZUvX1633367XnrpJaveAgAAgHr0kL7/Xnr8celf/5JeeUX66CPzdqtWVlfn2ywPtJI0atQojRo1Ksf7lixZkm3f6NGjNXr06GKuCgAAoGDKl5eWLDF7ax95RNq/X2rTRpo40dwCAqyu0DdZ3nIAAADga/r2lfbulfr3l9LSpKlTpdatzRlcFD0CLQAAQDGoXFlasUJ6912pYkVpzx6pZUtpxgwplSVrixSBFgAAoBgNGCDt2yf16SOlpEjPPGOeNHaN60ehEAi0AAAAxaxaNWntWrO/NjRU+uorc3mv2bOl9HSLi/MBBFoAAAAvcDikoUPN3tru3c0lvZ54Qrr9dunIEaurszcCLQAAgBdFRZlr1i5YYF5RbPNmqWlT6fXXJa4RVTgEWgAAAC9zOMyri337rdSxo3Txovn9HXdIJ05YXZ39EGgBAAAscsMN0mefSbNmSYGB0oYNUpMm0tKlzNYWBIEWAADAQn5+Zi/tnj3SrbdK58+bvbb9+kmnT1tdnT0QaAEAAEqAhg2l7dul6dMll8tcFeHGG6WVK62urOQj0AIAAJQQTqe5Tu3OnVLz5lJCgnm1sYEDzdvIGYEWAACghGneXNqxQ5o0SfL3N6841qSJ9O9/W11ZyUSgBQAAKIECAqTnn5e++MJsR4iLk/r2lR55REpLs7q6koVACwAAUILdcov0zTfSk0+ay3298Yb0zjtWV1WyEGgBAABKuOBgaeZM84QxSZo8WUpJsbSkEoVACwAAYBNjxkhVq0qHD0tLllhdTclBoAUAALCJMmXMVRAkaepU6coVa+spKQi0AAAANvLoo1KNGuYlct94w+pqSgYCLQAAgI0EBUl//at5e/p06dIla+spCQi0AAAANjN8uFS7tnlp3HnzrK7GegRaAAAAmwkIkJ57zrz90ktSYqK19ViNQAsAAGBDDz4oNWhgXhJ3zhyrq7EWgRYAAMCGnE5pyhTz9syZ0tmz1tZjJQItAACATT3wgNS0qdly8OqrVldjHQItAACATfn5Sc8/b96eM0c6c8baeqxCoAUAALCxvn2lVq2kixfNE8RKIwItAACAjTkc0rRp5u3586WTJ62txwoEWgAAAJvr0UPq0MG8FO4LL1hdjfcRaAEAAGwu8yztG29IR49aWo7XEWgBAAB8QKdOUrduUkqKNHWq1dV4F4EWAADAR7hXPPjXv6Qff7S2Fm8i0AIAAPiINm2ku+6S0tOlyZOtrsZ7CLQAAAA+xN1u8O670vffW1uLtxBoAQAAfMjNN0v33y8ZhvTcc1ZX4x0EWgAAAB8zZYq58sEHH0i7dlldTfEj0AIAAPiYxo2lBx80b//1r9bW4g0EWgAAAB80ebLk7y99/LG0fbvV1RQvAi0AAIAPuuEG6aGHzNu+PktLoAUAAPBRkyZJAQHSpk3Sxo1WV1N8CLQAAAA+qmZN6dFHzduTJpkrH/giAi0AAIAPmzBBCg6WvvjC7Kf1RQRaAAAAHxYRIT32mHnbV2dpCbQAAAA+7umnpbJlpd27zbVpfQ2BFgAAwMdVriw98YR5+9lnpbQ0a+spagRaAACAUmDsWKl8eWnfPmnFCqurKVoEWgAAgFKgfHnpqafM2889J6WmWlpOkSLQAgAAlBJjxkhVqkiHDvnWigcEWgAAgFKibFmpRw/z9v791tZSlAi0AAAApcgNN5hff/7Z2jqKEoEWAACgFCHQAgAAwNYItAAAALA1d6A9flxKTra2lqJCoAUAAChFwsOlMmXMS+AePWp1NUWDQAsAAFCKOBy+13ZAoAUAAChlCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDW3IH28GEpPd3aWooCgRYAAKCUqVlTcjrNdWhPnbK6mutHoAUAAChlnE4pOtq87QttBwRaAACAUsjddnDokLV1FAUCLQAAQClUt675lRlaAAAA2JIvrXRAoAUAACiFCLQAAACwNQItAAAAbK1OHfPruXPS2bOWlnLdCLQAAAClUEiIFBFh3rb7LC2BFgAAoJTylbYDAi0AAEApRaAFAACArfnKxRUItAAAAKWUr1xcgUALAABQStFyAAAAAFtzB9pTp6TLl62t5XoQaAEAAEqpihWlsDDz9uHD1tZyPQi0AAAApZTD4RttBwRaAACAUoxACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbK1GDfNrXJy1dVwPAi0AAEApFh5ufk1Ksu9atARaAACAUiw0VAoMNG+fOWNtLYVFoAUAACjFHA6palXz9unT1tZSWARaAACAUs7ddkCgBQAAgC25Z2hpOQAAAIAtMUMLAAAAW3MHWmZoAQAAYEucFAYAAABbo+UAAAAAtsZJYUVg/vz5ql27toKCgtSyZUtt3bo11+OTk5M1ceJERUdHKzAwUDfccIPefPNNL1ULAADgW+w+Q+u0uoAVK1bo8ccf1/z589W+fXu9/vrr6tWrl/bv36+aNWvm+Jj+/fvr9OnTWrRokerWraszZ84oNTXVy5UDAAD4BnegTUiQUlMlp+UJsWAsL3fWrFkaMWKEHn74YUnS7NmztX79ei1YsEAzZszIdvwnn3yizZs36/Dhw6pYsaIkqVatWrm+RnJyspKTkz3fJyYmSpJSUlKUkpJSRO/E97g/Gz6j0o1xAMYAJMaBrwsNlfz8nEpPdyg2NkXVqmU/xttjoCCv4zAMwyjGWnJ19epVhYSEaOXKlerXr59n/1/+8hft2bNHmzdvzvaYUaNG6ccff1SrVq301ltvqUyZMurbt6+ef/55BQcH5/g6kydP1pQpU7Ltf+eddxQSElJ0bwgAAMCmhg7tqfPng/S3v21S7dqJVpejS5cuadCgQTp//rxCQ0NzPdbSGdr4+HilpaUp3D3P/T/h4eGKi4vL8TGHDx/Wtm3bFBQUpA8++EDx8fEaNWqUzp49e80+2gkTJmjs2LGe7xMTExUVFaUePXrk+QGVZikpKYqJiVH37t3lcrmsLgcWYRyAMQCJcVAaREU5df681KBBR3Xrln2+09tjwP0b9fywvOVAkhwOR5bvDcPIts8tPT1dDodDb7/9tsLCwiSZbQv333+/5s2bl+MsbWBgoAIDA7Ptd7lc/KXMBz4nSIwDMAZgYhz4rvBwae9eKSHBqdz+iL01BgryGpauclC5cmX5+/tnm409c+ZMtllbt4iICNWoUcMTZiWpUaNGMgxDJ06cKNZ6AQAAfJWdrxZmaaANCAhQy5YtFRMTk2V/TEyM2rVrl+Nj2rdvr1OnTunChQuefT/++KP8/PwUGRlZrPUCAAD4KjtfLczydWjHjh2rf/7zn3rzzTd14MABPfHEEzp+/LhGjhwpyex/HTJkiOf4QYMGqVKlSho+fLj279+vLVu26KmnntJDDz10zZPCAAAAkDs7r0VreQ/tgAEDlJCQoKlTpyo2NlZNmjTRunXrFB0dLUmKjY3V8ePHPceXLVtWMTExGj16tFq1aqVKlSqpf//+mjZtmlVvAQAAwPbs3HJgeaCVzKW4Ro0aleN9S5YsybavYcOG2doUAAAAUHi0HAAAAMDW7DxDS6AFAABAlkBr3WW3CodACwAAAFWpYn69elU6d87SUgqMQAsAAAAFBUnuZf7t1nZAoAUAAIAk+54YRqAFAACAJPueGEagBQAAgCT7XlyBQAsAAABJtBwAAADA5mg5AAAAgK3RcgAAAABbo+UAAAAAtla9uvn11Clr6ygoAi0AAAAkSTVqmF9PnpTS062tpSAItAAAAJAkVasm+flJqanSr79aXU3+EWgBAAAgSXK5Mk4MO3HC2loKgkALAAAAj8xtB3ZBoAUAAIBHZKT5lUALAAAAW3LP0NJyAAAAAFtihhYAAAC2xgwtAAAAbI2TwgAAAGBr7pYDO83QOq/3Cc6cOaNjx47p8uXL2e677bbbrvfpAQAA4EXuGdoLF6TERCk01Np68qPQgTY2NlaDBw/Wpk2bst1nGIYcDofS0tKuqzgAAAB4V5kyUliYdP682Xbg04H2scce0+7du/XSSy+pWbNmCgwMLMq6AAAAYJHISDPQnjghNWpkdTV5K3Sg3bx5s2bOnKnhw4cXZT0AAACwWI0a0r599jkxrNAnhTkcDkVFRRVlLQAAACgB7LZ0V6ED7QMPPKD//Oc/RVkLAAAASgC7XVyh0C0H/fv31//93/8pPT1dffr0UaVKlbId06JFi+sqDgAAAN5ntxnaQgfa22+/XZI0d+5czZs3L8t9rHIAAABgX9Wrm19jY62tI78KHWgXL15clHUAAACghIiIML/6fKAdOnRoUdYBAACAEsIdaE+fltLSJH9/a+vJy3VfKUySfvzxRyUkJKhy5cqqV69eUTwlAAAALBIeLjkcZpiNjze/L8kKvcqBJK1cuVLR0dFq1KiROnTooIYNGyo6OlqrVq0qqvoAAADgZU6nVKWKedsObQeFDrTr1q3TwIEDFRYWphdffFFLly7VjBkzFBYWpoEDB+rjjz8uyjoBAADgRXbqoy10y8H06dPVo0cPffTRR/Lzy8jFTz31lHr16qVp06apV69eRVIkAAAAvCsiQvr2W3sE2kLP0O7Zs0ejRo3KEmYl8wpio0aN0rfffnvdxQEAAMAadpqhLXSg9ff319WrV3O8LyUlJVvQBQAAgH2UikB7yy236OWXX9bly5ez7E9OTtbMmTPVunXr6y4OAAAA1rBToC10D+2UKVPUtWtX1alTRw888ICqVaum2NhYrV69WgkJCdq4cWNR1gkAAAAvKhWBtkOHDtqwYYPGjx+vefPmyTAM+fn5qXXr1lq+fLnatWtXlHUCAADAi6pVM7/6dKCVpE6dOumLL77QpUuX9Ntvv6lChQoKCQkpqtoAAABgkcwztIZhbS15KZIrhYWEhBBkAQAAfIg70CYnS+fPS2XKWFtPbgoUaJcuXao777xTlSpV0tKlS/M8fsiQIYUuDAAAANYJDpbCwswwGxsr1a1rdUXXVqBAO2zYMH355ZeqVKmShg0bluuxDoeDQAsAAGBjERE+GGiPHDmiiP/NPx85cqRYCgIAAEDJEBEhHTxY8k8MK1CgjY6OzvE2AAAAfI9dlu4q0st5ffXVV1q4cKEOHDhQlE8LAAAAC9gl0BZ6lYOHH35YqampWrJkiSTp3Xff1YMPPijDMBQQEKBNmzapbdu2RVUnAAAAvMwugbbQM7SbNm3S7bff7vl++vTp6tmzp/bs2aN27drphRdeKJICAQAAYI2yZc2vly9bW0deCh1o4+LiPH20p06d0r59+zRhwgQ1a9ZMf/nLX/T1118XWZEAAADwPpfL/JqSYm0deSl0oHW5XLpy5Yokafv27QoKClKbNm0kSRUqVNC5c+eKpEAAAABYw+cDbcOGDfXWW28pKSlJixYtUvv27eX637s+ceKEqlSpUmRFAgAAwPuc/zvbqqQH2kKfFPbkk09q4MCBWr58uSRpzZo1nvs+/fRTNWvW7LqLAwAAgHXcM7SpqdbWkZdCB9oHHnhAUVFR+vzzz3XLLbeoY8eOnvsiIyN13333FUmBAAAAsIZdWg4KHWglqU2bNp6+2cymTJlyPU8LAACAEsAugbZIL6wAAAAA3+HuofWploM6derogw8+UPPmzVW7dm05HI5rHutwOPTzzz9fd4EAAACwhl1maAsUaDt16qTQ0FDP7dwCLQAAAOzNJwPt4sWLPbfdl7wFAACAb7LLsl300AIAACBHdlm2q9CBdvHixZo8eXKO902ePFlLly4t7FMDAACgBLBLy0GhA+1rr72mChUq5Hhf5cqV9dprrxW6KAAAAFjP5wPtoUOH1KRJkxzva9y4sX766adCFwUAAADr2WXZruvqoT1//vw196eW9HcOAACAXPn8DG3Tpk317rvv5njf8uXL1bRp00IXBQAAAOv5fKB97LHHtGrVKg0dOlRfffWVTp48qa+++krDhg3T+++/r9GjRxdlnQAAAPCygADza2qqlJ5ubS25KdA6tJkNGjRIBw8e1IwZM7Rs2TLPfj8/P02aNEkPPvhgkRQIAAAAa4SEZNy+fNm6OvJS6EArSVOnTtVDDz2kDRs2KD4+XlWqVFGPHj0UHR1dVPUBAADAIsHBGbcvXrSujrxcV6CVpFq1aumRRx4piloAAABQgvj5mbO0ly6V7EB7XascJCcn6/XXX9cf/vAH9ejRw7NU19q1a3X48OEiKRAAAADWKVPG/FqSA22hZ2jj4+PVpUsX7du3T9WqVdPp06eVlJQkSVqzZo3Wr1+v+fPnF1mhAAAA8D53H+2lSw5rC8lFoWdon376aZ07d05ff/21jh8/LsMwPPd16dJFmzdvLpICAQAAYB2fnqH9z3/+o5deekktWrRQWlpalvsiIyN14sSJ6y4OAAAA1socaP2uq1m1+BS6rMTExGuuZpCSksKVwgAAAHyAHWZoCx1oa9eurS+++CLH+3bs2KEGDRoUuigAAACUDO5Ae+mStXXkptCB9sEHH9RLL72ktWvXevpnHQ6Hdu7cqTlz5mjw4MFFViQAAACskRFoS+5JYYXuof1//+//afv27erXr58qVKggSerZs6cSEhJ0xx136C9/+UuRFQkAAABr2KHloNCB1uVyad26dVqxYoU++ugjnT59WpUrV9Zdd92lgQMHyq+kdg0DAAAg33w20F6+fFndunXTlClTNHDgQA0cOLCo6wIAAEAJ4LM9tMHBwfr+++/ldF73lXMBAABQgtlhhrbQfQFt27bVjh07irIWAAAAlDBly5pfL1zwwZPCXn31Vd19992qVq2a7r33XpV1v1sAAAD4jP+d+6/ffrO2jtxc1wztiRMnNHz4cIWFhalcuXIKDQ31bGFhYUVZJwAAACxQqZL5NSHB2jpyU+gZ2vvvv78o6wAAAEAJ5A60Z8/6UMvB5cuXtWbNGjVo0EBVqlRR3759VaVKleKoDQAAABarWNH86jMztKdOndJtt92mI0eOyDAMORwOjRs3Th9//LHatGlTXDUCAADAIu4Z2vPnHUpLK5mztAXqoZ00aZJOnjypSZMm6aOPPtLf/vY3BQQE6E9/+lNx1QcAAAALuU8Kk6SkJJd1heSiQDO0MTExeuaZZ/TXv/5VktSrVy/dcMMN6tu3r06fPq3w8PBiKRIAAADWcDql8uWlc+ekCxcCrC4nRwWaoY2Li9Ntt92WZV/nzp1lGIZOnz5dpIUBAACgZHC3HSQl+UCgTUtLU3BwcJZ9QUFBkqTU1NRCFzF//nzVrl1bQUFBatmypbZu3Zqvx23fvl1Op1M33XRToV8bAAAAuSvpgbbAqxz88MMPWS55m5aWJkk6ePBgtmNbtGiR5/OtWLFCjz/+uObPn6/27dvr9ddfV69evbR//37VrFnzmo87f/68hgwZoq5duzI7DAAAUIx8LtAOGzYsx/2DBw/23HavgOAOu7mZNWuWRowYoYcffliSNHv2bK1fv14LFizQjBkzrvm4Rx99VIMGDZK/v7/WrFlToPcAAACA/MsItD5wUtjixYuL9MWvXr2qXbt2afz48Vn29+jRQ59//nmudfz8889atmyZpk2blufrJCcnKzk52fN9YmKiJCklJUUpKSmFrN73uT8bPqPSjXEAxgAkxkFpV768nyR/JSUFeG0MFOR1ChRohw4dWuBichMfH6+0tLRsqyOEh4crLi4ux8f89NNPGj9+vLZu3Zql9SE3M2bM0JQpU7Lt37Bhg0JCQgpeeCkTExNjdQkoARgHYAxAYhyUVgkJ9SU1UlJSgNfGwKVLl/J9bKEvfVuUHI6si/S6WxZ+Ly0tTYMGDdKUKVNUv379fD//hAkTNHbsWM/3iYmJioqKUo8ePRQaGlr4wn1cSkqKYmJi1L17d7lcJfNXDCh+jAMwBiAxDkq7ffvMdQRSU/28Ngbcv1HPD0sDbeXKleXv759tNvbMmTM5rmmblJSkr7/+Wrt379Zjjz0mSUpPT5dhGHI6ndqwYYNuv/32bI8LDAxUYGBgtv0ul4u/lPnA5wSJcQDGAEyMg9Ip4H/nghmG98ZAQV6jQMt2FbWAgAC1bNky29R1TEyM2rVrl+340NBQff/999qzZ49nGzlypBo0aKA9e/aodevW3iodAACg1PD7X2JMTy+Zl761vOVg7NixGjx4sFq1aqW2bdvqH//4h44fP66RI0dKMtsFTp48qaVLl8rPz09NmjTJ8viqVasqKCgo234AAAAUDQJtHgYMGKCEhARNnTpVsbGxatKkidatW6fo6GhJUmxsrI4fP25xlQAAAKWXv7/51TCsreNaLA+0kjRq1CiNGjUqx/uWLFmS62MnT56syZMnF31RAAAAkFTyZ2gt7aEFAABAyeeeoSXQAgAAwJaYoQUAAICtlfQeWgItAAAAcsUMLQAAAGzNHWh37apmbSHXQKAFAABArvbutbqC3BFoAQAAkKvYWKsryB2BFgAAALlynxRWUhFoAQAAkCu/Ep4YS3h5AAAAsBoztAAAALA1ZmgBAABgawRaAAAA2BotBwAAALA1ZmgBAABga8zQAgAAwNaYoQUAAICtMUMLAAAAWyPQAgAAwNYItAAAALA1Ai0AAABszem0uoLcEWgBAACQK2ZoAQAAYGsEWgAAANgagRYAAAC2Rg8tAAAAbI0ZWgAAANgagRYAAAC2FhJidQW5I9ACAAAgV926WV1B7gi0AAAAyJW75cDPL93aQq6BQAsAAIBcORyeW1aWcU0EWgAAAOTKUTJzrAeBFgAAAPliGFZXkDMCLQAAAHLlnqE1DIcOHbK2lpwQaAEAAJCrzC0HS5aUvPhY8ioCAABAiZI50JbEtgMCLQAAAHJFoAUAAICtEWgBAABgawRaAAAA2Brr0AIAAMDWmKEFAACArRFoAQAAYGu0HAAAAMBnMEMLAAAA26HlAAAAALZGoAUAAICtEWgBAABgawRaAAAA2BqBFgAAALZGoAUAAICtEWgBAABgawRaAAAA2BpXCgMAAIDPYIYWAAAAtkPLAQAAAGyNQAsAAABbyxpoS15DLYEWAAAAuWKGFgAAALZGoAUAAIDPINACAADA1gi0AAAAsDUCLQAAAFDECLQAAADIN2ZoAQAAYGsEWgAAANgagRYAAAC2RqAFAACArRFoAQAAYGsEWgAAANgagRYAAAC2RqAFAACArb33XsmLjyWvIgAAAKAACLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbK1EBNr58+erdu3aCgoKUsuWLbV169ZrHrt69Wp1795dVapUUWhoqNq2bav169d7sVoAAACUJJYH2hUrVujxxx/XxIkTtXv3bnXs2FG9evXS8ePHczx+y5Yt6t69u9atW6ddu3apS5cu6tOnj3bv3u3lygEAAFASWB5oZ82apREjRujhhx9Wo0aNNHv2bEVFRWnBggU5Hj979mw9/fTTuuWWW1SvXj298MILqlevnv797397uXIAAACUBE4rX/zq1avatWuXxo8fn2V/jx499Pnnn+frOdLT05WUlKSKFSte85jk5GQlJyd7vk9MTJQkpaSkKCUlpRCVlw7uz4bPqHRjHIAxAIlxAElyeW55YxwU5DUsDbTx8fFKS0tTeHh4lv3h4eGKi4vL13O8+uqrunjxovr373/NY2bMmKEpU6Zk279hwwaFhIQUrOhSKCYmxuoSUAIwDsAYgMQ4KN3u9txat25dsb/apUuX8n2spYHWzeFwZPneMIxs+3KyfPlyTZ48WWvXrlXVqlWvedyECRM0duxYz/eJiYmKiopSjx49FBoaWvjCfVxKSopiYmLUvXt3uVyuvB8An8Q4AGMAEuMAWfXu3bvYX8P9G/X8sDTQVq5cWf7+/tlmY8+cOZNt1vb3VqxYoREjRmjlypXq1q1brscGBgYqMDAw236Xy8Vfynzgc4LEOABjACbGASR5ZQwU5DUsPSksICBALVu2zPbri5iYGLVr1+6aj1u+fLmGDRumd955R3feeWdxlwkAAIASzPKWg7Fjx2rw4MFq1aqV2rZtq3/84x86fvy4Ro4cKclsFzh58qSWLl0qyQyzQ4YM0Zw5c9SmTRvP7G5wcLDCwsIsex8AAACwhuWBdsCAAUpISNDUqVMVGxurJk2aaN26dYqOjpYkxcbGZlmT9vXXX1dqaqr+/Oc/689//rNn/9ChQ7VkyRJvlw8AAACLWR5oJWnUqFEaNWpUjvf9PqR+9tlnxV8QAAAAbMPyCysAAAAA14NACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAAbI1ACwAAAFsj0AIAAMDWCLQAAACwNQItAAAA8i001LC6hGwItAAAAMi3qCirK8iOQAsAAIB827fPYXUJ2RBoAQAAkG/VqtFyAAAAABuLi2OGFgAAAChSBFoAAADYGoEWAAAAtkagBQAAgK0RaAEAAGBrBFoAAADYGoEWAAAAtkagBQAAgK0RaAEAAGBrBFoAAADYGoEWAAAAtkagBQAAgK0RaAEAAGBrBFoAAADYGoEWAAAAtkagBQAAgK0RaAEAAGBrBFoAAADYGoEWAAAAtkagBQAAgK0RaAEAAGBrBFoAAADYGoEWAAAAtkagBQAAgK0RaAEAAGBrBFoAAADYGoEWAAAAtkagBQAAgK0RaAEAAJBvTqdhdQnZEGgBAACQb4cOpVpdQjYEWgAAAOTp6tUUrVmzVtWrW11JdgRaAAAA2BqBFgAAALZGoAUAAICtEWgBAABgawRaAAAA2BqBFgAAALZGoAUAAICtEWgBAABgawRaAAAA2BqBFgAAALZGoAUAAICtEWgBAABgawRaAAAA2BqBFgAAALZGoAUAAICtEWgBAABgawRaAAAA2BqBFgAAALbmtLoAKxiGIUlKTEy0uJKSLSUlRZcuXVJiYqJcLpfV5cAijAMwBiAxDuD9MeDOae7clptSGWiTkpIkSVFRURZXAgAAgNwkJSUpLCws12McRn5ir49JT0/XqVOnVK5cOTkcDqvLKbESExMVFRWlX375RaGhoVaXA4swDsAYgMQ4gPfHgGEYSkpKUvXq1eXnl3uXbKmcofXz81NkZKTVZdhGaGgoP7zAOABjAJIYB/DuGMhrZtaNk8IAAABgawRaAAAA2BqBFtcUGBio5557ToGBgVaXAgsxDsAYgMQ4QMkeA6XypDAAAAD4DmZoAQAAYGsEWgAAANgagRYAAAC2RqAFAACArRFoS7n58+erdu3aCgoKUsuWLbV169ZrHrt69Wp1795dVapUUWhoqNq2bav169d7sVoUl4KMg8y2b98up9Opm266qXgLRLEr6BhITk7WxIkTFR0drcDAQN1www168803vVQtiktBx8Hbb7+t5s2bKyQkRBERERo+fLgSEhK8VC2K2pYtW9SnTx9Vr15dDodDa9asyfMxmzdvVsuWLRUUFKQ6depo4cKFxV9oDgi0pdiKFSv0+OOPa+LEidq9e7c6duyoXr166fjx4zkev2XLFnXv3l3r1q3Trl271KVLF/Xp00e7d+/2cuUoSgUdB27nz5/XkCFD1LVrVy9ViuJSmDHQv39/ffrpp1q0aJF++OEHLV++XA0bNvRi1ShqBR0H27Zt05AhQzRixAjt27dPK1eu1M6dO/Xwww97uXIUlYsXL6p58+aaO3duvo4/cuSIevfurY4dO2r37t165plnNGbMGL3//vvFXGkODJRat956qzFy5Mgs+xo2bGiMHz8+38/RuHFjY8qUKUVdGryosONgwIABxqRJk4znnnvOaN68eTFWiOJW0DHw8ccfG2FhYUZCQoI3yoOXFHQcvPLKK0adOnWy7HvttdeMyMjIYqsR3iPJ+OCDD3I95umnnzYaNmyYZd+jjz5qtGnTphgryxkztKXU1atXtWvXLvXo0SPL/h49eujzzz/P13Okp6crKSlJFStWLI4S4QWFHQeLFy/Wzz//rOeee664S0QxK8wY+PDDD9WqVSu9/PLLqlGjhurXr69x48bp8uXL3igZxaAw46Bdu3Y6ceKE1q1bJ8MwdPr0aa1atUp33nmnN0pGCfDFF19kGzM9e/bU119/rZSUFK/W4vTqq6HEiI+PV1pamsLDw7PsDw8PV1xcXL6e49VXX9XFixfVv3//4igRXlCYcfDTTz9p/Pjx2rp1q5xOfoTYXWHGwOHDh7Vt2zYFBQXpgw8+UHx8vEaNGqWzZ8/SR2tThRkH7dq109tvv60BAwboypUrSk1NVd++ffX3v//dGyWjBIiLi8txzKSmpio+Pl4RERFeq4UZ2lLO4XBk+d4wjGz7crJ8+XJNnjxZK1asUNWqVYurPHhJfsdBWlqaBg0apClTpqh+/freKg9eUJCfBenp6XI4HHr77bd16623qnfv3po1a5aWLFnCLK3NFWQc7N+/X2PGjNGzzz6rXbt26ZNPPtGRI0c0cuRIb5SKEiKnMZPT/uLG9EopVblyZfn7+2f7n/eZM2ey/W/r91asWKERI0Zo5cqV6tatW3GWiWJW0HGQlJSkr7/+Wrt379Zjjz0myQw3hmHI6XRqw4YNuv32271SO4pGYX4WREREqEaNGgoLC/Psa9SokQzD0IkTJ1SvXr1irRlFrzDjYMaMGWrfvr2eeuopSVKzZs1UpkwZdezYUdOmTfPq7BysUa1atRzHjNPpVKVKlbxaCzO0pVRAQIBatmypmJiYLPtjYmLUrl27az5u+fLlGjZsmN555x36pHxAQcdBaGiovv/+e+3Zs8ezjRw5Ug0aNNCePXvUunVrb5WOIlKYnwXt27fXqVOndOHCBc++H3/8UX5+foqMjCzWelE8CjMOLl26JD+/rDHC399fUsYsHXxb27Zts42ZDRs2qFWrVnK5XN4txuunoaHEePfddw2Xy2UsWrTI2L9/v/H4448bZcqUMY4ePWoYhmGMHz/eGDx4sOf4d955x3A6nca8efOM2NhYz3bu3Dmr3gKKQEHHwe+xyoH9FXQMJCUlGZGRkcb9999v7Nu3z9i8ebNRr1494+GHH7bqLaAIFHQcLF682HA6ncb8+fONn3/+2di2bZvRqlUr49Zbb7XqLeA6JSUlGbt37zZ2795tSDJmzZpl7N692zh27JhhGNnHwOHDh42QkBDjiSeeMPbv328sWrTIcLlcxqpVq7xeO4G2lJs3b54RHR1tBAQEGC1atDA2b97suW/o0KFGp06dPN936tTJkJRtGzp0qPcLR5EqyDj4PQKtbyjoGDhw4IDRrVs3Izg42IiMjDTGjh1rXLp0yctVo6gVdBy89tprRuPGjY3g4GAjIiLCePDBB40TJ054uWoUlU2bNuX673xOY+Czzz4zbr75ZiMgIMCoVauWsWDBAu8XbhiGwzD4vQAAAADsix5aAAAA2BqBFgAAALZGoAUAAICtEWgBAABgawRaAAAA2BqBFgAAALZGoAUAAICtEWgBAABgawRaAPCiJUuWyOFweDan06mIiAgNHDhQP/30k9XlqVatWho2bJjn+6NHj8rhcGjJkiWW1QQAeXFaXQAAlEaLFy9Ww4YNdeXKFW3fvl3Tp0/Xpk2bdPDgQVWoUMHq8gDAVgi0AGCBJk2aqFWrVpKkzp07Ky0tTc8995zWrFmj4cOHW1wdANgLLQcAUAK4w+3p06c9+77++mv17dtXFStWVFBQkG6++Wa999572R578uRJPfLII4qKilJAQICqV6+u+++/3/NcV65c0ZNPPqmbbrpJYWFhqlixotq2bau1a9d6580BQDFjhhYASoAjR45IkurXry9J2rRpk+644w61bt1aCxcuVFhYmN59910NGDBAly5d8vS5njx5UrfccotSUlL0zDPPqFmzZkpISND69ev122+/KTw8XMnJyTp79qzGjRunGjVq6OrVq/rvf/+re++9V4sXL9aQIUOsetsAUCQItABggbS0NKWmpnp6aKdNm6bbbrtNffv2lSSNGjVKN954ozZu3Cin0/xR3bNnT8XHx+uZZ57RkCFD5Ofnp2effVbx8fH69ttv1ahRI8/z9+/f33M7LCxMixcvzvLaXbt21W+//abZs2cTaAHYHi0HAGCBNm3ayOVyqVy5crrjjjtUoUIFrV27Vk6nU4cOHdLBgwf14IMPSpJSU1M9W+/evRUbG6sffvhBkvTxxx+rS5cuWcJsTlauXKn27durbNmycjqdcrlcWrRokQ4cOFDs7xUAihuBFgAssHTpUu3cuVMbN27Uo48+qgMHDugPf/iDpIw+2nHjxsnlcmXZRo0aJUmKj4+XJP3666+KjIzM9bVWr16t/v37q0aNGlq2bJm++OIL7dy5Uw899JCuXLlSjO8SALyDlgMAsECjRo08J4J16dJFaWlp+uc//6lVq1apadOmkqQJEybo3nvvzfHxDRo0kCRVqVJFJ06cyPW1li1bptq1a2vFihVyOBye/cnJyUXxVgDAcgRaACgBXn75Zb3//vt69tlntXfvXtWrV0/ffvutXnjhhVwf16tXL7311lv64YcfPCH39xwOhwICArKE2bi4OFY5AOAzaDkAgBKgQoUKmjBhgg4cOKB33nlHr7/+uj799FP17NlTy5cv15YtW7RmzRrNmDFDDzzwgOdxU6dOVeXKlXXbbbdpzpw52rhxo1avXq1HHnlEBw8elCTddddd+uGHHzRq1Cht3LhR//rXv9ShQwdFRERY9XYBoEgxQwsAJcTo0aM1d+5cTZ06VQcOHNCOHTs0ffp0Pf744/rtt99UqVIlNW7cOMsKBjVq1NCOHTv03HPP6cUXX1RCQoKqVKmiDh06qGLFipKk4cOH68yZM1q4cKHefPNN1alTR+PHj9eJEyc0ZcoUq94uABQZh2EYhtVFAAAAAIVFywEAAABsjUALAAAAWyPQAgAAwNYItAAAALA1Ai0AAABsjUALAAAAWyPQAgAAwNYItAAAALA1Ai0AAABsjUALAAAAWyPQAgAAwNb+Py8ShF/wGu84AAAAAElFTkSuQmCC",
      "text/plain": [
       "<Figure size 800x600 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "def plot_PRC(P_list, R_list):\n",
    "    # data clean\n",
    "    valid_indices = (~np.isnan(P_list)) & (~np.isnan(R_list)) & (~np.isinf(P_list)) & (~np.isinf(R_list))\n",
    "    P_array = P_list[valid_indices]\n",
    "    R_array = R_list[valid_indices]\n",
    "\n",
    "    # sort data\n",
    "    sorted_indices = np.argsort(R_array)\n",
    "    R_sorted = R_array[sorted_indices]\n",
    "    P_sorted = P_array[sorted_indices]\n",
    "\n",
    "    # plot data\n",
    "    plt.figure(figsize=(8, 6))\n",
    "    plt.plot(R_sorted, P_sorted, linestyle='-', color='b')\n",
    "    plt.xlabel('Recall', fontsize=12)\n",
    "    plt.ylabel('Precision', fontsize=12)\n",
    "    plt.title('Precision-Recall Curve', fontsize=14)\n",
    "    plt.grid(True)\n",
    "    plt.show()\n",
    "\n",
    "P_list = []\n",
    "R_list = []\n",
    "for q in np.arange(0, 1, 0.01):\n",
    "    print(f\"Progress: {q * 100:.0f}% (q = {q:.2f})\", end='\\r')\n",
    "    _, (P, R), _ = assess_performance(noise_removal(X, 81, q), vis_flag=False)\n",
    "    P_list.append(P)\n",
    "    R_list.append(R)\n",
    "\n",
    "# plot PR-Curve\n",
    "plot_PRC(np.array(P_list), np.array(R_list))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
